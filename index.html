<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Art Gallery</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
            background: #000;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            z-index: 100;
        }
        #info h1 {
            margin: 0 0 10px 0;
            font-size: 24px;
        }
        #info p {
            margin: 5px 0;
            font-size: 14px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 8px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1>ðŸŽ¨ Modern Art Gallery</h1>
        <p>Use mouse to look around</p>
        <p>WASD or Arrow keys to move</p>
        <p>Click on art pieces to view info</p>
    </div>
    <div id="controls">
        <p>Interactive Three.js Gallery â€¢ Explore the Space</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        scene.fog = new THREE.Fog(0x1a1a1a, 1, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1.6, 8);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(5, 10, 5);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        // Add spotlights for art pieces
        const spotlights = [];
        for (let i = 0; i < 10; i++) {
            const spotlight = new THREE.SpotLight(0xffffff, 2, 20, Math.PI / 6, 0.5, 1);
            spotlight.castShadow = true;
            spotlights.push(spotlight);
            scene.add(spotlight);
        }

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a2a,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Gallery walls
        const wallMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf5f5f5,
            roughness: 0.9
        });

        // Back wall
        const backWall = new THREE.Mesh(new THREE.BoxGeometry(30, 5, 0.2), wallMaterial);
        backWall.position.set(0, 2.5, -10);
        backWall.receiveShadow = true;
        scene.add(backWall);

        // Side walls
        const leftWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 30), wallMaterial);
        leftWall.position.set(-15, 2.5, 0);
        leftWall.receiveShadow = true;
        scene.add(leftWall);

        const rightWall = new THREE.Mesh(new THREE.BoxGeometry(0.2, 5, 30), wallMaterial);
        rightWall.position.set(15, 2.5, 0);
        rightWall.receiveShadow = true;
        scene.add(rightWall);

        // Create art pieces
        const artPieces = [];

        // Art Piece 1: Abstract Geometric
        function createArtPiece1() {
            const group = new THREE.Group();
            const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0xa8e6cf];
            
            for (let i = 0; i < 4; i++) {
                const size = Math.random() * 0.5 + 0.3;
                const geometry = new THREE.BoxGeometry(size, size, 0.1);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[i],
                    roughness: 0.3,
                    metalness: 0.1
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = (Math.random() - 0.5) * 1.5;
                mesh.position.y = (Math.random() - 0.5) * 1.5;
                mesh.rotation.z = Math.random() * Math.PI;
                mesh.castShadow = true;
                group.add(mesh);
            }
            return group;
        }

        // Art Piece 2: Concentric Circles
        function createArtPiece2() {
            const group = new THREE.Group();
            const colors = [0x667eea, 0x764ba2, 0xf093fb, 0x4facfe];
            
            for (let i = 0; i < 4; i++) {
                const radius = (i + 1) * 0.2;
                const geometry = new THREE.TorusGeometry(radius, 0.05, 16, 100);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[i],
                    roughness: 0.2,
                    metalness: 0.5
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                group.add(mesh);
            }
            return group;
        }

        // Art Piece 3: Spiral
        function createArtPiece3() {
            const group = new THREE.Group();
            const points = [];
            
            for (let i = 0; i < 50; i++) {
                const angle = i * 0.3;
                const radius = i * 0.02;
                points.push(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    Math.sin(angle) * radius,
                    0
                ));
            }
            
            const geometry = new THREE.TubeGeometry(
                new THREE.CatmullRomCurve3(points),
                50,
                0.05,
                8,
                false
            );
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xfeca57,
                roughness: 0.3,
                metalness: 0.7
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            group.add(mesh);
            return group;
        }

        // Art Piece 4: Floating Spheres
        function createArtPiece4() {
            const group = new THREE.Group();
            const colors = [0xff6348, 0x1e90ff, 0x2ed573, 0xffa502];
            
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.SphereGeometry(0.15, 32, 32);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[i % colors.length],
                    roughness: 0.2,
                    metalness: 0.6
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.x = (Math.random() - 0.5) * 1.2;
                mesh.position.y = (Math.random() - 0.5) * 1.2;
                mesh.castShadow = true;
                group.add(mesh);
            }
            return group;
        }

        // Art Piece 5: Helix
        function createArtPiece5() {
            const group = new THREE.Group();
            const colors = [0xe056fd, 0x686de0, 0x30336b];
            
            for (let j = 0; j < 3; j++) {
                for (let i = 0; i < 20; i++) {
                    const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: colors[j],
                        roughness: 0.3,
                        metalness: 0.5
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    const angle = (i / 20) * Math.PI * 2;
                    mesh.position.x = Math.cos(angle + j * Math.PI * 2 / 3) * 0.5;
                    mesh.position.y = (i - 10) * 0.08;
                    mesh.position.z = Math.sin(angle + j * Math.PI * 2 / 3) * 0.5;
                    mesh.castShadow = true;
                    group.add(mesh);
                }
            }
            return group;
        }

        // Art Piece 6: Waves
        function createArtPiece6() {
            const group = new THREE.Group();
            const colors = [0x48dbfb, 0x0abde3, 0x00d2d3];
            
            for (let j = 0; j < 3; j++) {
                const points = [];
                for (let i = 0; i < 30; i++) {
                    points.push(new THREE.Vector3(
                        (i - 15) * 0.08,
                        Math.sin(i * 0.5 + j) * 0.3,
                        j * 0.1 - 0.1
                    ));
                }
                const geometry = new THREE.TubeGeometry(
                    new THREE.CatmullRomCurve3(points),
                    30,
                    0.03,
                    8,
                    false
                );
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[j],
                    roughness: 0.2,
                    metalness: 0.7
                });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.castShadow = true;
                group.add(mesh);
            }
            return group;
        }

        // Art Piece 7: Particle Storm
        function createArtPiece7() {
            const group = new THREE.Group();
            const particles = 50;
            const colors = [0xff6b9d, 0xc44569, 0xffa502, 0xff6348, 0xee5a6f];
            
            for (let i = 0; i < particles; i++) {
                const geometry = new THREE.SphereGeometry(0.03, 8, 8);
                const material = new THREE.MeshStandardMaterial({ 
                    color: colors[i % colors.length],
                    roughness: 0.3,
                    metalness: 0.7,
                    emissive: colors[i % colors.length],
                    emissiveIntensity: 0.3
                });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Random position in sphere
                const radius = Math.random() * 0.8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                mesh.position.x = radius * Math.sin(phi) * Math.cos(theta);
                mesh.position.y = radius * Math.sin(phi) * Math.sin(theta);
                mesh.position.z = radius * Math.cos(phi);
                mesh.castShadow = true;
                
                // Store animation data
                mesh.userData = {
                    basePos: mesh.position.clone(),
                    offset: i
                };
                
                group.add(mesh);
            }
            return group;
        }

        // Art Piece 8: Mandelbrot Fragment
        function createArtPiece8() {
            const group = new THREE.Group();
            const colors = [0x9b59b6, 0x8e44ad, 0x2c3e50, 0x34495e];
            const iterations = 20;
            
            for (let x = -10; x < 10; x++) {
                for (let y = -10; y < 10; y++) {
                    const cx = x / 15 - 0.5;
                    const cy = y / 15;
                    
                    let zx = 0, zy = 0;
                    let i = 0;
                    
                    while (i < iterations && zx * zx + zy * zy < 4) {
                        const tmp = zx * zx - zy * zy + cx;
                        zy = 2 * zx * zy + cy;
                        zx = tmp;
                        i++;
                    }
                    
                    if (i < iterations && i > 2) {
                        const geometry = new THREE.BoxGeometry(0.05, 0.05, i * 0.02);
                        const material = new THREE.MeshStandardMaterial({ 
                            color: colors[i % colors.length],
                            roughness: 0.4,
                            metalness: 0.6
                        });
                        const mesh = new THREE.Mesh(geometry, material);
                        mesh.position.x = x * 0.05;
                        mesh.position.y = y * 0.05;
                        mesh.position.z = i * 0.01;
                        mesh.castShadow = true;
                        group.add(mesh);
                    }
                }
            }
            return group;
        }

        // Art Piece 9: DNA Twist
        function createArtPiece9() {
            const group = new THREE.Group();
            const segments = 30;
            const radius = 0.4;
            
            // Create two helixes
            for (let helix = 0; helix < 2; helix++) {
                const helixGroup = new THREE.Group();
                const color = helix === 0 ? 0x00d2d3 : 0xf368e0;
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 4 + (helix * Math.PI);
                    const y = (i / segments) * 2 - 1;
                    
                    // Nucleotide sphere
                    const geometry = new THREE.SphereGeometry(0.08, 16, 16);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color,
                        roughness: 0.2,
                        metalness: 0.8,
                        emissive: color,
                        emissiveIntensity: 0.2
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.x = Math.cos(angle) * radius;
                    mesh.position.y = y;
                    mesh.position.z = Math.sin(angle) * radius;
                    mesh.castShadow = true;
                    helixGroup.add(mesh);
                    
                    // Connecting bars (every 3 nucleotides)
                    if (i % 3 === 0 && i < segments - 1) {
                        const barGeometry = new THREE.CylinderGeometry(0.02, 0.02, radius * 2, 8);
                        const barMaterial = new THREE.MeshStandardMaterial({ 
                            color: 0xdcdde1,
                            roughness: 0.5,
                            metalness: 0.3
                        });
                        const bar = new THREE.Mesh(barGeometry, barMaterial);
                        bar.position.y = y;
                        bar.rotation.z = Math.PI / 2;
                        bar.castShadow = true;
                        group.add(bar);
                    }
                }
                group.add(helixGroup);
            }
            return group;
        }

        // Art Piece 10: Crystal Lattice
        function createArtPiece10() {
            const group = new THREE.Group();
            const colors = [0x00f2c3, 0x0cd8e4, 0x00d9ff, 0x48dbfb];
            const latticeSize = 5;
            
            for (let x = -latticeSize; x <= latticeSize; x++) {
                for (let y = -latticeSize; y <= latticeSize; y++) {
                    for (let z = -latticeSize; z <= latticeSize; z++) {
                        // Only create vertices at specific lattice points
                        if ((x + y + z) % 2 === 0) {
                            const geometry = new THREE.OctahedronGeometry(0.06, 0);
                            const material = new THREE.MeshStandardMaterial({ 
                                color: colors[(Math.abs(x) + Math.abs(y) + Math.abs(z)) % colors.length],
                                roughness: 0.1,
                                metalness: 0.9,
                                transparent: true,
                                opacity: 0.8
                            });
                            const mesh = new THREE.Mesh(geometry, material);
                            mesh.position.set(x * 0.15, y * 0.15, z * 0.15);
                            mesh.castShadow = true;
                            group.add(mesh);
                            
                            // Add connecting lines
                            if (x < latticeSize) {
                                const lineGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 4);
                                const lineMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0xaaaaaa,
                                    roughness: 0.7,
                                    metalness: 0.3
                                });
                                const line = new THREE.Mesh(lineGeometry, lineMaterial);
                                line.position.set(x * 0.15 + 0.075, y * 0.15, z * 0.15);
                                line.rotation.z = Math.PI / 2;
                                group.add(line);
                            }
                        }
                    }
                }
            }
            return group;
        }

        // Position art pieces
        const artData = [
            { create: createArtPiece1, pos: [-10, 2.5, -9.8], name: "Abstract Geometry" },
            { create: createArtPiece2, pos: [-5, 2.5, -9.8], name: "Concentric Dreams" },
            { create: createArtPiece3, pos: [0, 2.5, -9.8], name: "Golden Spiral" },
            { create: createArtPiece4, pos: [5, 2.5, -9.8], name: "Floating Cosmos" },
            { create: createArtPiece5, pos: [10, 2.5, -9.8], name: "Triple Helix" },
            { create: createArtPiece6, pos: [0, 2.5, 5], name: "Ocean Waves" },
            { create: createArtPiece7, pos: [-14, 2.5, 0], name: "Particle Storm" },
            { create: createArtPiece8, pos: [-14, 2.5, -5], name: "Mandelbrot Fragment" },
            { create: createArtPiece9, pos: [14, 2.5, 0], name: "DNA Twist" },
            { create: createArtPiece10, pos: [14, 2.5, -5], name: "Crystal Lattice" }
        ];

        artData.forEach((data, i) => {
            const art = data.create();
            art.position.set(...data.pos);
            art.userData = { name: data.name };
            scene.add(art);
            artPieces.push(art);
            
            // Position spotlight
            spotlights[i].position.set(data.pos[0], data.pos[1] + 2, data.pos[2] + 1);
            spotlights[i].target = art;
        });

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        
        const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false
        };

        document.addEventListener('click', () => {
            controls.lock();
        });

        document.addEventListener('keydown', (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveState.forward = true;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveState.backward = true;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveState.left = true;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveState.right = true;
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch (event.code) {
                case 'KeyW':
                case 'ArrowUp':
                    moveState.forward = false;
                    break;
                case 'KeyS':
                case 'ArrowDown':
                    moveState.backward = false;
                    break;
                case 'KeyA':
                case 'ArrowLeft':
                    moveState.left = false;
                    break;
                case 'KeyD':
                case 'ArrowRight':
                    moveState.right = false;
                    break;
            }
        });

        // Animation
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let time = 0;

        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;

            // Animate art pieces
            artPieces.forEach((art, i) => {
                art.rotation.y = Math.sin(time + i) * 0.1;
                
                // Special animation for Particle Storm (piece 7, index 6)
                if (i === 6 && art.children.length > 0) {
                    art.children.forEach((particle) => {
                        if (particle.userData.basePos) {
                            const offset = particle.userData.offset;
                            particle.position.x = particle.userData.basePos.x + Math.sin(time * 2 + offset) * 0.1;
                            particle.position.y = particle.userData.basePos.y + Math.cos(time * 2 + offset) * 0.1;
                            particle.position.z = particle.userData.basePos.z + Math.sin(time * 3 + offset) * 0.1;
                        }
                    });
                }
            });

            // Movement
            if (controls.isLocked) {
                const speed = 0.1;
                
                velocity.x -= velocity.x * 10.0 * 0.016;
                velocity.z -= velocity.z * 10.0 * 0.016;

                direction.z = Number(moveState.forward) - Number(moveState.backward);
                direction.x = Number(moveState.right) - Number(moveState.left);
                direction.normalize();

                if (moveState.forward || moveState.backward) {
                    velocity.z -= direction.z * speed;
                }
                if (moveState.left || moveState.right) {
                    velocity.x -= direction.x * speed;
                }

                controls.moveRight(-velocity.x);
                controls.moveForward(-velocity.z);
            }

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
